# Как приложению работать с БД?

В начале я обозначу некоторые проблемы при работе с БД, покажу дыры в абстракциях.
Далее мы разберем более простую абстракцию, основанную на иммутабельности.

Предполагается, что читатель знаком с паттерном Active Record.
Я хорошо знаком с его реализаций из Rails: ActiveRecord.
Также я буду ссылаться на концепции релизации паттерна Data Mapper - Hibernate.

Это не критика ActiveRecord и Rails. Они хороши для своей ниши.

Контекст статьи: достаточно большие проекты, которые нельзя выкинуть и быстро переписать.

## Dirty checking

Рассмотрим следующий код на ruby:

```ruby
post.title += " (Editor's Choice)"
post.save
```
Напомню, что в ruby по умолчанию строки мутабельны.
Из-за этого [Dirty](https://api.rubyonrails.org/classes/ActiveModel/Dirty.html)
не может отследить это in-place изменение.

"Правильное" решение выглядит так:

```ruby
post.title_will_change!
post.title += " (Editor's Choice)"
post.save
```

Одна из стратегий
[dirty checking](https://vladmihalcea.com/the-anatomy-of-hibernate-dirty-checking/)
в Hibernate - это сохранение снимка сущности после ее восстановления из БД
и сравнение этого снимка с состоянием сущности.

## Identity map

Следующая проблема - проблема сохранения идентичности.
Идентичность - нечто, что однозначно задает сущность.
В базе данных - это первичный ключ, а в памяти - ссылка (указатель).
Хорошо, когда ссылки указывают только на один объект.

В Active Record это не так:

```ruby
post_a = Post.find 1
post_b = Post.find 1

post_a.object_id != post_b.object_id # true

post_a.title = "foo"
post_b.title != "foo" # true
```

Т.е. мы получаем 2 ссылки на 2 разных объекта в памяти.

Таким образом, мы можем потерять  изменения,
если по невнимательности начнем работать с одной и той же сущностью,
но представленной разными объектами.

Hibernate имеет сессию, фактически кэш первого уровня, который хранит сопоставление идентификатора сущности
на объект в памяти. Если мы повторно запросим ту же сущность, то получим ссылку на существующий объект.
Т.е. Hibernate реализует паттерн [Identity Map](https://martinfowler.com/eaaCatalog/identityMap.html).

## Долгие транзакции

Но, что если мы делаем выборки не по идентификатору?
Чтобы не допустить рассинхронизации состояния объектов и состояния бд,
Hibernate перед запросом выборки делает
[flush](https://docs.jboss.org/hibernate/stable/core.old/reference/en/html/objectstate-flushing.html),
т.е. сохраняет "грязные" объекты, чтобы запрос прочитал согласованные данные.

Это вынуждает держать открытой транзакцию БД, пока идет бизнес транзакция.
Если бизнес тразакция долгая, то простаивает, в том числе, и ответсвенныйй за соединение процесс в самой БД.
Например, это может случиться, если бизнес транзакция запрашивает данные по сети или выполняет сложные расчеты.

## N+1

Пожалуй самая большая "дыра" в абстракции ORM - проблема N+1 запроса.

```ruby
posts = Post.all # select * from posts
posts.each do |post|
  like = post.likes.order(id: :desc).first
  # SELECT * FROM likes WHERE post_id = ? ORDER BY id DESC LIMIT 1
  # ...
end
```

ORM склоняет программиста к мысли, что он работает просто с объектами в памяти.
Но он работает с доступным по сети сервисом, а на установление соединений и передачу данных
тербеуется время (latency). Даже если запрос выполняется 10ms, то при 100 запросов будут выполняться секунду.

## Дополнительные данные

Скажем, чтобы избежать описанной выше проблемы N+1, вы пишете такой
[запрос](https://www.db-fiddle.com/f/6m5FACAHWCeRSmKrTXriVH/2):

```sql
SELECT * FROM posts JOIN LATERAL (
  SELECT * FROM likes WHERE post_id = posts.id ORDER BY likes.id DESC LIMIT 1
) as last_like ON true;
```

Т.е. кроме атрибутов поста, выбирается еще и атрибуты последнего лайка.
Что если бы мы выбирали только часть атрибутуов?
На какую сущность отобразить эти данные?
И нужно ли вообще их отображение? Может быть оставить их просто данными?

## State & identity

Рассмотрим код на js:

```js
const alice = { id: 0, name: 'Alice' };
```

Здесь ссылке на объект дали имя `alicie`.
Т.к. это константа, то нет возможности назвать Алисой другой объект.
При этом сам объект остался мутабельным.

Например, мы можем присвоить существующий идентификатор:

```js
const bob = { id: 1, name: 'Bob' };
alice.id = bob.id;
```

Напомню, что у сущности есть 2 идентичности: ссылка и первичный ключ в БД.
И константы не могут помешать сделать Алису Бобом, пусть даже после сохранения.

Объект, ссылку на который мы назвали `alice`, выполняет 2 обязанности:
одновременно моделирует идентичность и состояние.
Cостояние - это значение, описывающие сущность в заданный момент времени.

А что если разделить эти 2 обязанности и сделать состояние неизменяемым?

```js
function Ref(initialState, validator) {
  let state = initialState;

  this.deref = () => state;
  this.swap = (updater) => {
    const newState = updater(state);
    if (! validator(state, newState) ) throw "Invalid state";
    state = newState;
    return newState;
  };
}

const UserState = Immutable.Record({ id: null, name: '' });

const aliceState = new UserState({id: 0, name: 'Alice'});
const alice = new Ref( aliceState, (oldS, newS) => oldS.id === newS.id );

alice.swap( oldS => oldS.set('name', 'Queen Alice') );
alice.swap( oldS => oldS.set('id', 1) ); // BOOM!
```

## Storage

Рассмотрим следующий API:

```js
storage.tx( t => {
  const alice = t.getOne(0);
  const bobState = new UserState({id: 1, name: 'Bob'});
  const bob = t.create(bobState);
  alice.swap( oldS => oldS.update('friends', old => old.push(bob.deref.id)) );
});
```

Мы открываем бизнес транзакцию `t`, находим Алису по ее идентификатору, создаем Боба и указываем,
что Алиса считает Боба своим другом.

`t.getOne` и `t.create` возвращает `ref`.
При этом объект `t` хранит внутри себя отображение идентификаторов на `ref`
и при повторном извлечении Алисы, запроса в БД не будет.

Объект `t` контролирует создание  `ref`. Он может, например, запоминать начальное состояние
сучщностей, чтобы в конце транзакции отследить какие изменения нужно записать в БД.
Подробнее в описании паттерна [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html).
Или мы можем добавить к `Ref` наблюдателей и при каждом изменении `ref` сбрасывать изменения в БД.
Т.е. это оптимиситический и пессимистический подходы к фиксации изменений.

При оптимистическом подходе каждая сущность должна иметь версию.
При измлечении из БД мы должны запомнить версию, а при фиксации изменений проверить, что версия сущности
в БД не отличается от начальной. В противно случае нужно повторить бизнес транзакцию.
Такой подход позволяет использовать групповые операции вставки и удаления и очень короткие транзакции БД,
что экономит ресурсы.

При пессимистическом подходе транзакция БД полностью соответствует бизнес транзакции.
Т.е. мы вынуждены забирать соединение из пула коннектов на время всей транзакции.

Т.к. у нас реализован паттерн Identity Map, то мы можем ввести в API метод `preload`:

```js
storage.tx( t => {
  t.preload([0, 1, 2, 3]);
  const alice = t.getOne(0); // from cache
});
```

## Queries

Если мы не хотим длинных транзакций, то мы не можем делать выборки по произвольному ключу,
т.к. произойдет рассинхронизация объектов в памяти и БД.

Мы можем воспользоваться Запросами (Query) и извлекать любые данные (состояние) вне транзакции
и перечитать данные находясь в транзакции.

```js
const aliceId = userQuery.findByEmail('alice@mail.com');
storage.tx( t => {
  const alice = t.getOne(aliceId);
});
```

Запросы не возвращают сущности. Они возвращают просто данные, а данные, это в том числе и состояния сущностей.

## Comands

Бывают ситуации, когда операцию можно выполнить без чтения данных.
Например, списать деньги со всех клиентов. Или вставить или обновить данные (upsert).

В случае проблем производительностью связку из Storage и Query можно заменить командой.

## Связи

Сущности имеют связи.
Двунаправленые связи сложно реализовать и поддерживать, поэтому их сводят к однонаправленным.
Связи между сущностями упорядочивают, например, выделяя
[агрегаты](https://martinfowler.com/bliki/DDD_Aggregate.html).

Каждый агрегат имеет корневую сущность и вложенные сущности.
Любая внешняя сущность может ссылаться только на корень агрегата.
Корень отслеживает целостность всего агрегата.
Транзакция не может пересекать границу агрегата, иными словами в транзакции участвует агрегат целиком.
Подробнее на

Наш API работает с целыми агрегатами. При этом обеспечение ссылочной целостности ложится на
